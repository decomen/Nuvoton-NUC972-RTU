/*
 * File      : startup.c
 */

#include <board.h>

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>

extern int  rt_application_init(void);

static int __check_das_self(void)
{
#define DAS_LOCK_FILE       "/var/run/das.pid"
    int fd;
    int lock_result;
    struct flock lock;
    char pid_str[32] = {0};
    
    fd = open(DAS_LOCK_FILE, O_RDWR | O_CREAT);
    if (fd < 0) {
        printf ("open %s failed (%s).\n", DAS_LOCK_FILE, strerror(errno));
        return -1;
    }
    lock_result = lockf(fd, F_TLOCK, 0);
    if (lock_result < 0) {
        read(fd, pid_str, sizeof(pid_str));
        printf ("das is already running (pid : %s).\n", pid_str);
        return -1;
    }
    sprintf(pid_str, "%d", getpid());
    ftruncate(fd, 0);
    write(fd, pid_str, strlen(pid_str));
    printf ("das running (pid : %s).\n", pid_str);
    return 0;
}

void rtthread_startup(void)
{
    das_os_init();
    
    /* init board */
    rt_hw_board_init();

    /* init application */
    rt_application_init();

    return ;
}

void das_show_version(void)
{
    char cmd[1024] = "echo '";
    char buf[32] = {0};
    int pos = 6;    // echo '
    time_t t = time(0);
    ctime_r(&t, buf);
    if (buf[0]) buf[strlen(buf) - 1] = '\0';
    pos += sprintf(&cmd[pos], "==================================================\n");
    pos += sprintf(&cmd[pos], "=============%s=============\n", buf);
    pos += sprintf(&cmd[pos], "==================================================\n");
    pos += sprintf(&cmd[pos], "  ___    _    ___ \n");
    pos += sprintf(&cmd[pos], " |   \\  /_\\  / __|\n");
    pos += sprintf(&cmd[pos], " | |) |/ _ \\ \\__ \\\n");
    pos += sprintf(&cmd[pos], " |___//_/ \\_\\|___/\n\n");
    pos += sprintf(&cmd[pos], " Version: %d.%02d build %s, %s\n", DAS_VER_VERCODE / 100, DAS_VER_VERCODE % 100, __DATE__, __TIME__);
    pos += sprintf(&cmd[pos], " 2018 - 2020 Copyright by jay\n");
    pos += sprintf(&cmd[pos], "==================================================\n");

    printf("%s\n", &cmd[6]);
    
    pos += sprintf(&cmd[pos], "' > /tmp/das_version.log");
    my_system(cmd);
}

/*
extern const rt_uint8_t c_xAESKeyAndIV[16];
void test_aes(void)
{
      char plaintest[1024] = {0};
     const char ciphertest[]={0x8d,0x80,0xdb,0x2e,0x20,0x85,0xca,0xdb,0x5f,0xa6,0x8f,0xdd,0x66,0x4d,0xe4,0x33,0x62,0xe2,0x53,0x52,0x08,0xa2,0x7e,0xbe,0xde,0xa8,0x54,0x84,0x55,0x3f,0xb5,0xfa,0x4a,0x48,0x75,0xa4,0x00,0xcc,0xb6,
0xe8,0xa9,0x72,0x16,0x71,0xc3,0xb0,0x4d,0x44,0x59,0xb5,0x71,0x20,0x3f,0x33,0xe9,0x2e,0xc1,0x18,0xe6,0x05,0xa3,0xde,0x03,0x82,0x9d,0xee,0xc2,0x1a,0x87,0x38,0xc0,0x57,0x96,0x48,0x1b,0x4b,0x01,0x33,
0x12,0x7b,0x5f,0xec,0xf0,0xd8,0x1e,0x30,0xc9,0x83,0x42,0xc5,0x2f,0xe4,0x71,0x65,0xfd,0xcc,0x80,0x28,0xe0,0x4d,0xea,0x48,0xfe,0xa1,0x1f,0x8c,0xc9,0x9d,0xf3,0xd8,0xe9,0xaa,0xf0,0x03,0x98,0xa1,0xb2,
0xb8,0x50,0x91,0xe5,0x82,0xeb,0xe9,0xef,0x54,0x44,0xae,0x5e,0x37,0xa4,0xd6,0x85,0xcf,0xae,0x4f,0x00,0x3e,0x74,0xe9,0x87,0x03,0x54,0x61,0x85,0x9d,0xad,0x62,0xea,0xa0,0x44,0x58,0xd4,0x10,0x89,0xb4,
0x3e,0xd9,0xd5,0x11,0x70,0x4c,0xc4,0xc4,0xdc,0x10,0xf6,0x05,0xb9,0xa1,0x5d,0xa0,0x84,0x51,0x4b,0x2b,0x31,0x0b,0xf9,0x42,0xf0,0xa1,0xaa,0x73,0x44,0xda,0x24,0x24,0xc0,0x6a,0x71,0xbb,0x8c,0x91,0xa1,
0xd0,0x91,0x14,0xb2,0x34,0x5d,0x15,0x72,0xbb,0x2e,0x4a,0x88,0xaa,0x88,0x77,0x07,0xab,0x08,0x45,0xf8,0x21,0x45,0xeb,0x70,0x69,0x50,0xef,0x1c,0x46};
      AES_Init(c_xAESKeyAndIV);
      AES_Decrypt(plaintest, ciphertest, sizeof(ciphertest), c_xAESKeyAndIV);
      printf("\nplaintest: %s\n\n",plaintest);
}*/


int main(void)
{
    if (__check_das_self() != 0) {
        return -1;
    }

   // test_aes();
    
    das_show_version();
    rtthread_startup();
    
    for (;;) sleep(1000);
}

